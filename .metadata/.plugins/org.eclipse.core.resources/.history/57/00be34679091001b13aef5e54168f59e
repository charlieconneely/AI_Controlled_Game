package ie.gmit.sw.ai;

import java.util.concurrent.ThreadLocalRandom;

public class Scavenger implements Command {

	private GameModel model;
	private char enemyID;
	private int row, col;
	private DepthLimitedSearch dls;
	private static ThreadLocalRandom rand = ThreadLocalRandom.current();
	
	public Scavenger(GameModel model, char enemyID, int row, int col) {
		this.model = model;
		this.enemyID = enemyID;
		this.row = row;
		this.col = col;
		dls = new DepthLimitedSearch(model);
	}

	@Override
	public boolean execute() {
		
		// if touching player or hunter - die
		if (isTouchingPlayer('1') || isTouchingPlayer('5')) {
			model.set(row, col, '\u0020');
			return false;
		}
		
		//Randomly pick a direction up, down, left or right
		int temp_row = row, temp_col = col;
		if (rand.nextBoolean()) {
    		temp_row += rand.nextBoolean() ? 1 : -1;
    	}else {
    		temp_col += rand.nextBoolean() ? 1 : -1;
    	}
		
		if (model.isValidMove(row, col, temp_row, temp_col, enemyID)) {
    		model.set(temp_row, temp_col, enemyID);
    		model.set(row, col, '\u0020');
    		row = temp_row;
    		col = temp_col;
    		return true;
		}
				
		int nearCharacter = dls.search(row, col, 5);
		if (nearCharacter == 1) {
			System.out.println("Near player");
		} else if (nearCharacter == 5) {
			System.out.println("Near evil ghost");
		}
		
		// call to nn here 
		
		// if nn returns 1
		scavenge(temp_row, temp_col);
		
		return true;
	}
	
	private void scavenge(int r, int c) {
		if (model.get(r, c) == '0') {
			// eat hedge
			model.set(r, c, '\u0020');
			// increment strength
		}
	}
	
	// check if player or hunter is in any position surrounding character
	private boolean isTouchingPlayer(char c) {
		if (model.get(row - 1, col) == c || model.get(row + 1, col) == c
			|| model.get(row, col - 1) == c || model.get(row, col + 1) == c) {
			return true;
		}
		return false;
	}
}
