package ie.gmit.sw.ai;

import java.util.LinkedList;
import  java.lang.Math;

public class PathFinder {
	
	private LinkedList<Node> closed = new LinkedList<Node>();
	// Collections.sort(open)
	private LinkedList<Node> open = new LinkedList<Node>();
	//private Node[][] nodes;
	private GameModel model;
	private NodeMap nodeMap;
	private int maxSearchDistance = 50;
	
	public PathFinder(GameModel model) {
		this.model = model;
		nodeMap = new NodeMap(model.getModel());
	}
	
	public Path findPath(int sx, int sy, int tx, int ty) {
		// initialization
		nodes[sx][sy].setCost(0);
		nodes[sx][sy].setDepth(0);
		closed.clear();
		open.clear();
		open.add(nodes[sx][sy]);
		
		nodes[tx][ty].setParent(null);
		
		int maxDepth = 0;
		while((open.size() != 0) && maxDepth < maxSearchDistance) {
			Node current = open.getFirst();
			if (current == nodes[tx][ty]) {
				// found destination node
				break;
			}
			open.remove(current);
			closed.add(current);
			
			for (int x = -1; x < 2; x++) {
				for (int y=-1;y<2;y++) {
					if ((x == 0) && (y == 0)) continue;
					if ((x != 0) && (y != 0)) continue;
					
					int xp = x + current.getX();
					int yp = y + current.getY();
					
					if (isValidLocation(xp, yp)) {
						int nextStepCost = current.getCost() + 
                                getMovementCost(current.getX(), current.getY(), xp, yp);
						Node neighbour = nodes[xp][yp];
						nodeMap.pathFinderVisited(xp, yp);
						
						if (nextStepCost < neighbour.getCost()) {
							if (open.contains(neighbour)) {
								open.remove(neighbour);
							}
							if (closed.contains(neighbour)) {
								closed.remove(neighbour);
							}
						}
						
						if (!open.contains(neighbour) && !closed.contains(neighbour)) {
							neighbour.setCost(nextStepCost);
							neighbour.setParent(current);
							//maxDepth = Math.max(maxDepth, neighbour.setParent(current));
							//maxDepth++;
							neighbour.setHeuristic(getMovementCost(xp, yp, tx, ty));
							open.add(neighbour);
						}
					}
				}
			}
		}
		
		if () {
			
		}
		
		return new Path();
	}
	
	private int getMovementCost(int sx, int sy, int tx, int ty) {
		// Manhattan distance
	    int dx = Math.abs(tx - sx);
	    int dy = Math.abs(ty - sy);
	    int heuristic = dx+dy;
		return heuristic;	
	}
	
	private boolean isValidLocation(int x, int y) {
		if (x >= 0 && y >= 0 && x < model.size() + 1 && y < model.size() + 1) {
			if (model.get(x, y) == ' ') {
				return true;
			}
		}
		return false;
	}
		
	// calculate cost of movement from one pos to another based on heuristic
	private float getCost(int sr, int sc, int tr, int tc) {
		return 0;
	}

}
